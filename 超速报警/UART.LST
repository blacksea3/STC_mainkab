C51 COMPILER V9.00   UART                                                                  06/02/2016 00:46:33 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN UART.OBJ
COMPILER INVOKED BY: E:\software\DevelopmentSoftware\InstallSrc\KeilC51\C51\BIN\C51.EXE UART.c LARGE BROWSE DEBUG OBJECT
                    -EXTEND

line level    source

   1          /*UART.c
   2          使用STC官方文档代码*/
   3          
   4          #include "reg51.h"
   5          #include "intrins.h"
   6          #include "main.h"
   7          #include "Timer.h"
   8          
   9          typedef unsigned char BYTE;
  10          typedef unsigned int WORD;
  11          
  12          #define FOSC 11059200L                      //系统频率
  13          #define BAUD 115200                         //串口波特率
  14          
  15          #define NONE_PARITY 0                       //无校验
  16          #define ODD_PARITY 1                        //奇校验
  17          #define EVEN_PARITY 2                       //偶校验
  18          #define MARK_PARITY 3                       //标记校验
  19          #define SPACE_PARITY 4                      //空白校验
  20          
  21          #define PARITYBIT NONE_PARITY               //定义校验位
  22          
  23          #define PARITYBIT2 NONE_PARITY              //定义校验位
  24          
  25          sfr AUXR = 0x8e;                            //辅助寄存器
  26          sfr T2H = 0xd6;                                 //定时器2高8位
  27          sfr T2L = 0xd7;                                 //定时器2低8位
  28          sbit P22 = P2^2;
  29          bit busy,busy2;
  30          
  31          sfr S2CON = 0x9a;                                                       //UART2控制寄存器
  32          sfr S2BUF = 0x9b;                                                       //UART2数据寄存器
  33          sfr IE2 = 0xaf;                                                         //中断控制寄存器2
  34          
  35          sfr IP2 = 0xB5;                                                         //xxxx,xx00 中断优先级寄存器2
  36          
  37          #define S2RI 0x01                                                       //S2CON.0
  38          #define S2TI 0x02                                                       //S2CON.1
  39          #define S2RB8 0x04                                                      //S2CON.2
  40          #define S2TB8 0x08                                                      //S2CON.3
  41          
  42          
  43          void SendData(BYTE dat);
  44          void SendString(char *s);
  45          void UARTInit();
  46          
  47          //unsigned char UART2Temp[256];
  48          //unsigned int UART2Loc = 0;
  49          //unsigned char UART1Temp[256];
  50          //unsigned int UART1Loc = 0;
  51          unsigned char UART1Temp;
  52          unsigned char UART2Temp;
  53          
  54          void UARTInit()
C51 COMPILER V9.00   UART                                                                  06/02/2016 00:46:33 PAGE 2   

  55          {
  56   1      #if(PARITYBIT == NONE_PARITY)
  57   1              SCON = 0x50;                                    //8位可变波特率
  58   1      #elif(PARITYBIT == ODD_PARITY)||(PARITYBIT == EVEN_PARITY)||(PARITYBIT == MARK_PARITY)
                      SCON = 0xda;                                    //9位可变波特率,校验位初始为1
              #elif(PARITYBIT == SPACE_PARITY)        
                      SCON = 0xd2;                                    //9位可变波特率,校验位初始为0
              #endif
  63   1              
  64   1          //T2L = (65536-(FOSC/4/BAUD));              //设置波特率重装值
  65   1              //T2H = (65536-(FOSC/4/BAUD))>>8;
  66   1              TL1 = (65536-(FOSC/4/BAUD));
  67   1              TH1 = (65536-(FOSC/4/BAUD))>>8;
  68   1              TMOD = 0x00;
  69   1              //AUXR |= 0x14;                                 //T2 1T模式,启动定时器2
  70   1              //AUXR |= 0x01;                                         //定时器2为串口1的波特率发生器
  71   1              AUXR |= 0x40;                                   //定时器1为串口1波特率发生器
  72   1              AUXR &= ~0xbf;                                  //定时器1为串口1波特率发生器
  73   1      
  74   1              TR1 = 1;                                                                //启动定时器1
  75   1              ES = 1;                                         //使能串口1中断
  76   1              PS = 1;                                 //UART中断调整为高优先级
  77   1              //EA = 1;                                       //使能总中断
  78   1              //SendString("SSDSDSD");
  79   1              //while(1)
  80   1              //{
  81   1              //       SendString("A");
  82   1              //}
  83   1      }
  84          
  85          void UART2Init()
  86          {
  87   1      #if(PARITYBIT2 == NONE_PARITY)
  88   1              S2CON = 0x50;                                   //8位可变波特率
  89   1      #elif(PARITYBIT2 == ODD_PARITY)||(PARITYBIT2 == EVEN_PARITY)||(PARITYBIT2 == MARK_PARITY)
                      S2CON = 0xda;                                   //9位可变波特率,校验位初始为1
              #elif(PARITYBIT2 == SPACE_PARITY)       
                      S2CON = 0xd2;                                   //9位可变波特率,校验位初始为0
              #endif
  94   1          T2L = (65536-(FOSC/4/BAUD));                //设置波特率重装值
  95   1              T2H = (65536-(FOSC/4/BAUD))>>8;
  96   1              AUXR |= 0x14;                                   //T2 1T模式,启动定时器2
  97   1              AUXR |= 0x01;                                   //定时器2为串口1的波特率发生器
  98   1              IE2 |= 0x01;                            //使能串口2中断
  99   1              //UART2Loc = 0;
 100   1              IP2 |= 0x01;                                                    //UART2中断调整为高优先级
 101   1              IP2 &= ~0xfe;
 102   1              //PS2 = 1;                                              
 103   1      }
 104          
 105          /*-------------------------
 106          UART1 中断服务程序
 107          -------------------------*/
 108          void Uart() interrupt 4
 109          {
 110   1              if(RI)
 111   1              {
 112   2                      RI = 0;                     //清除RI位
 113   2                      UART1Temp = SBUF;
 114   2                      //UART1Temp[UART1Loc++] = SBUF;   
 115   2                      UART1RIREADY = 1;
 116   2                      if(WIFINEEDDELAY == 0)
C51 COMPILER V9.00   UART                                                                  06/02/2016 00:46:33 PAGE 3   

 117   2                      {
 118   3                              EnableTimer4();
 119   3                              WIFINEEDDELAY = 1;
 120   3                      }
 121   2                      else
 122   2                      {
 123   3                              T4times = 0;
 124   3                      }
 125   2              }
 126   1              if(TI)
 127   1              {
 128   2                      TI = 0;                     //清除TI位
 129   2                      busy = 0;                   //清忙标志
 130   2              }
 131   1      }
 132          
 133          /*--------------------------
 134          UART1发送数据
 135          --------------------------*/
 136          void SendData(BYTE dat)
 137          {
 138   1              while(busy);                     //等待前面的数据发送完成
 139   1              ACC = dat;                       //获取校验位P(PSW.0)
 140   1              if(P)
 141   1              {
 142   2              #if(PARITYBIT == ODD_PARITY)
                              TB8 = 0;                     //设置校验位为0
                      #elif(PARITYBIT == EVEN_PARITY)
                              TB8 = 1;                     //设置校验位为1
                      #endif
 147   2              }
 148   1              else
 149   1              {
 150   2              #if(PARITYBIT == ODD_PARITY)
                              TB8 = 1;                     //设置校验位为0
                      #elif(PARITYBIT == EVEN_PARITY)
                              TB8 = 0;                     //设置校验位为1
                      #endif
 155   2              }
 156   1              busy = 1;
 157   1              SBUF = ACC;                      //写数据到UART数据寄存器
 158   1              
 159   1      }
 160          
 161          /*--------------------------
 162          发送字符串
 163          --------------------------*/
 164          void SendString(char *s)
 165          {
 166   1              while(*s)                        //检测字符串结束标志
 167   1              {
 168   2                      SendData(*s++);              //发送当前字符
 169   2              }
 170   1              
 171   1      }
 172          
 173          /*
 174           * 串口1发串口2接收的信息
 175           */
 176          void Uart1SendUart2String()
 177          {
 178   1          //unsigned char i;
C51 COMPILER V9.00   UART                                                                  06/02/2016 00:46:33 PAGE 4   

 179   1              //for(i=0;i<UART2Loc;i++)
 180   1              //{
 181   1              //      SendData(UART2Temp[i]);
 182   1              //}
 183   1              //UART2Loc = 0;
 184   1              SendData(UART2Temp);
 185   1      }
 186          
 187          /*-------------------------
 188          UART2 中断服务程序
 189          -------------------------*/
 190          void Uart2() interrupt 8
 191          {
 192   1              if(S2CON&S2RI)
 193   1              {
 194   2                      S2CON&=~S2RI;                   //清除RI位
 195   2                      //UART2Temp[UART2Loc++] = S2BUF;   
 196   2                      UART2RIREADY = 1;
 197   2                      UART2Temp = S2BUF;
 198   2                      if(WIFINEEDDELAY == 0)
 199   2                      {
 200   3                              EnableTimer4();
 201   3                              WIFINEEDDELAY = 1;
 202   3                      }
 203   2                      else
 204   2                      {
 205   3                              T4times = 0;
 206   3                      }
 207   2                      //SendData(SBUF);
 208   2                      //P22 = RB8;                    //P2.2显示检验位
 209   2              }
 210   1              if(S2CON&S2TI)
 211   1              {
 212   2                      S2CON&=~S2TI;                   //清除TI位
 213   2                      busy2 = 0;                              //清忙标志
 214   2              }
 215   1      }
 216          
 217          /*--------------------------
 218          UART2发送数据
 219          --------------------------*/
 220          void SendData2(BYTE dat)
 221          {
 222   1              while(busy2);                           //等待前面的数据发送完成
 223   1              ACC = dat;                              //获取校验位P(PSW.0)
 224   1              if(P)
 225   1              {
 226   2              #if(PARITYBIT2 == ODD_PARITY)
                              S2CON&=~S2TB8;                  //设置校验位为0
                      #elif(PARITYBIT2 == EVEN_PARITY)
                              S2CON|=~S2TB8;                  //设置校验位为1
                      #endif
 231   2              }
 232   1              else
 233   1              {
 234   2              #if(PARITYBIT2 == ODD_PARITY)
                              S2CON|=~S2TB8;                  //设置校验位为1
                      #elif(PARITYBIT2 == EVEN_PARITY)
                              S2CON&=~S2TB8;                  //设置校验位为0
                      #endif
 239   2              }
 240   1              busy2 = 1;
C51 COMPILER V9.00   UART                                                                  06/02/2016 00:46:33 PAGE 5   

 241   1              S2BUF = ACC;                            //写数据到UART数据寄存器
 242   1              
 243   1      }
 244          
 245          /*--------------------------
 246          UART2发送字符串
 247          --------------------------*/
 248          void SendString2(char *s)
 249          {
 250   1              while(*s)                               //检测字符串结束标志
 251   1              {
 252   2                      SendData2(*s++);                //发送当前字符
 253   2              }
 254   1      }
 255          
 256          void SendString2Length(char s[], unsigned char length)
 257          {
 258   1              unsigned char i;
 259   1              for(i=0;i<length;i++)
 260   1              {
 261   2                      SendData2(s[i]);                //发送当前字符
 262   2              }
 263   1              
 264   1      }
 265          
 266          /*
 267           * 串口2发串口1接收的信息
 268           */
 269          void Uart2SendUart1String()
 270          {
 271   1          //unsigned char i;
 272   1              //for(i=0;i<UART1Loc;i++)
 273   1              //{
 274   1              SendData2(UART1Temp);
 275   1              //}
 276   1              //UART1Loc = 0;
 277   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    441    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      2       9
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

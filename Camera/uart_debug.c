/****************《51单片机轻松入门-基于STC15W4K系列》配套例程 *************
 ★★★★★★★★★★★★★★★★★★★★★★★★
 《51单片机轻松入门-基于STC15W4K系列》 一书已经由北航出版社正式出版发行。
  作者亲手创作的与教材配套的51双核实验板(2个MCU)对程序下载、调试、仿真方便，不需要外部
  仿真器与编程器，这种设计方式彻底解决了系统中多个最高优先级谁也不能让谁的中断竞争问题。
  淘宝店地址：https://shop117387413.taobao.com
  QQ群：STC51-STM32(3) ：515624099 或 STC51-STM32(2)：99794374。
        验证信息：STC15单片机
  邮箱：xgliyouquan@126.com
  ★★★★★★★★★★★★★★★★★★★★★★★★*/

#include "stc15.h"           // 包含 "STC15W4K.H"寄存器定义头文件 
#include <string.h>	  
/******************************************************************
功能：将一个32位长整型变量dat转为字符串，比如把1234转为"1234"
参数：dat:待转的long型的变量
      str:指向字符数组的指针，转换后的字节串放在其中    
返回：转换后的字符串长度			        
 ******************************************************************/ 
unsigned char Long_Str(long dat,unsigned char *str) // 长整型数转换为字符串，返回值为转换后的字符串长度
{
	signed char i=0;
	unsigned char len = 0;
	unsigned char buf[11];	   // 长整数最大值4294967295，转ASCII码后占用10+1=11字节 
	if (dat < 0)               // 如果为负数，首先取绝对值，并添加负号
	{
		dat = -dat;
		*str++ = '-';
		len++;
	}
	do 
	{                               // 低位在前高位在后顺序排列
		buf[i++] = dat % 10+0x30;	// C语言中数组下标固定从0开始
		dat /= 10;
	} while (dat > 0);
    len += i;                 // i最后的值就是有效字符的个数
    while (i-- > 0)           // 高位在前低位在后顺序排列
    {
        *str++ = buf[i] ;
    }     
	*str = 0;                 // 添加字符串结束符方便使用KEIL自带的字符串处理函数处理
	return len;               // 返回字符串长度
}

/******************************************************************
功能：将一个字符串转为32位长整型变量，比如"1234"转为1234
参数：str:指向待转换的字符串           
返回：转换后的数值										       
 ******************************************** **********************/ 
unsigned long Str_Long(char *str) 
{
	 unsigned long temp=0;
	 unsigned long fact=1;
	 unsigned char len=strlen(str);	// <string.h>头文件包含strlen()函数	
	 unsigned char i;		// strlen()函数计算的字符串长度不包含最后一个空字符(值0)
	 for(i=len;i>0;i--)															   
	 {
		temp+=((str[i-1]-0x30)*fact);  // 数组下标从0开始
		fact*=10;
	 }
	 return temp;
}

/**************************************************************************
功能：STC15单片机串口1初始化,使用T1方式2自重载方式做波特率发生器 
 **************************************************************************/
/*void UART_init(void)
{		  
	// 下面代码设置定时器1
	TMOD |= 0x20;	// 0010 0000 定时器1工作于方式2（8位自动重装方式）
	TH1  = 0xFA;	// 波特率：9600 /22.1184MHZ
	TL1  = 0xFA;	// 波特率：9600 /22.1184MHZ
	TR1  = 1;
	// 下面代码设置定串口
	AUXR = 0x00;             // 很关键，使用定时器1作为波特率发生器，S1ST2=0
	SCON = 0x50; 	// 01010 0000 SM0.SM1=01(最普遍的8位通信）,REN=1（允许接受）
	// 下面代码设置中断
	ES   = 1;		// 关键：开启了中断就必须编写相应的中断函数，哪怕是中断空函数，
	                // 但必须有,否则程序进入中断入口地址后（这里是0023H)不能跳出，必然出错
	EA   = 1;
}*/  

void UART_init(void)		//115200bps@22.1184MHz
{
	SCON = 0x50;		//8位数据,可变波特率
	AUXR |= 0x40;		//定时器1时钟为Fosc,即1T
	AUXR &= 0xFE;		//串口1选择定时器1为波特率发生器
	TMOD &= 0x0F;		//设定定时器1为16位自动重装方式
	TL1 = 0xD0;		//设定定时初值
	TH1 = 0xFF;		//设定定时初值
	ET1 = 0;		//禁止定时器1中断
	TR1 = 1;		//启动定时器1
}


/**************************************************************************
功能：STC15单片机的串口发送字节的函数
参数：dat:要发送的一个字节   
**************************************************************************/
void UART_Send_Byte(unsigned char dat)
{
	ES=0;		 // 使用查询发送结束方式，禁止中断干预
	SBUF = dat;
	while(!TI);	    
 	TI=0;	 //此句可以不要，不影响后面数据的发送，只供代码查询数据是否发送完成
	ES=1;
}	
/**************************************************************************
功能：STC15单片机的串口发送0d 0a ，即回车换行 
注：此函数就是发送0d 0a这两个字节，在"串口助手"上会有回车换行的效果
 **************************************************************************/  
void UART_Send_Enter()
{
	UART_Send_Byte(0x0d); // 转义字符常量\r，ASCII码值（10进制）=13，光标移到本行行首
	UART_Send_Byte(0x0a); // 转义字符常量\n，ASCII码值（10进制）=10，光标移到下行行首
}

/*
void UART_Send_Str(char *buf)
{
	while (*buf != '\0')   //说明：C语言字符串数组结尾必然有一个"\0"字符，在内存中数值为0
	{
		UART_send_byte(*buf++);	 //说明：* 和 ++优先级相同，结合性从右到左，但是++运
	}							 //算符有个特性就是先让变量参与运算，后进行加1操作
}	 */

/**************************************************************************
功能：51单片机的串口发送字符串  
参数：s:指向字符串的指针	  
注：如果在字符串中有'\n'，则会发送一个回车换行
 **************************************************************************/
void UART_Send_Str(char *s)
{
	unsigned int i; 	
	unsigned int len=strlen(s)-1;		// 最后一个字符单独处理
	for(i=0;i<len;i++) 
		UART_Send_Byte(s[i]);		// 	while (*buf != '\0')  UART_Send_Byte(*s++);
	if(s[i]=='\n') 			     
	{
		UART_Send_Enter();
	}
	else
	{
		UART_Send_Byte(s[i]);	// 普通字符正常发送
	}
}
/**************************************************************************
功能：51单片机的串口发送数值
参数：dat:要发送的数值(长整数)
  注：函数中会将数值转为相应的字符串，发送出去。比如 4567 转为 "4567" 
 **************************************************************************/
void UART_Send_Num(unsigned long dat)
{
	unsigned char temp[11];		// 长整数最大值4294967295，转ASCII码后占用10字节
	    //	由于后面程序要使用strlen()库函数计算长度，需增加1个字节存放结束符0
	Long_Str(dat,temp);	  
	UART_Send_Str(temp);
	UART_Send_Enter();          // 发送回车 
}
/**************************************************************************
功能：51单片机的串口发送调试信息（字符串+数值）	  
参数：inf:指向提示信息字符串的指针
      dat:一个数值，前面的提示信息就是在说明这个数值的意义
 **************************************************************************/
void UART_Send_StrNum(char *inf,unsigned long dat)
{
	UART_Send_Str(inf);
	UART_Send_Num(dat);	
} 

void UART_Put_Inf(char *inf,unsigned long dat)
{
	UART_Send_StrNum(inf, dat);
}

/**************************************************************************
功能：16进制转ASCII码函数
 **************************************************************************/
unsigned char Hex_ASCII(unsigned int hex,char *str)
{
	unsigned char temp=0;
	
	temp=((hex&0xf000)>>12);	  // 4位1表示范围0_9_A_F
	str[0]=(temp>=10)?(temp-10+'A'):(temp+0x30);
		// 0_9的ASCII码是0_9+ 0x30，
	    // A_F的ASCII码: A代表数值10，A的ASCII码是65，因此数值+55=ASCII
		// 因此算式(temp-10+'A')=(temp-10+65)=(temp+55)
		// 分析依据：ASCII码表
	temp=((hex&0x0f00)>>8);
	str[1]=(temp>=10)?(temp-10+'A'):(temp+0x30);
	
	temp=((hex&0x00f0)>>4);
	str[2]=(temp>=10)?(temp-10+'A'):(temp+0x30);
	
	temp=((hex&0x000f)>>0);
	str[3]=(temp>=10)?(temp-10+'A'):(temp+0x30);
	
	str[4]=0;	    // 由于要使用KEIL自带的字符串处理函数处理，必须有结束标记。 
	
	return 0;
} 

/**************************************************************************
功能：51单片机的串口输出ASCII码函数（接收端按字符形式接收则显示为HEX格式	）
 **************************************************************************/
void UART_Send_Hex(unsigned int hex)
{
	unsigned char temp[11];
	Hex_ASCII(hex,temp);
	UART_Send_Str(temp);
	UART_Send_Enter();          // 发送回车
}

/**************************************************************************
功能：51单片机的串口发送调试信息（二进制数据显示）	  
参数：dat:需要按2进制形式显示变量
 **************************************************************************/
void UART_Send_binary(unsigned char dat)
{
	unsigned char i;
	unsigned char a[17];
	for(i=0;i<8;i++)
	{
		a[i]=((dat<<i)&0x80)?'1':'0';
	}
	a[i]=0;
	for(i=0;i<strlen(a);i++)
	{
		UART_Send_Byte(a[i]);
		UART_Send_Byte(' ');
	}
	UART_Send_Enter();          // 发送回车
}
/**************************************************************************
功能：51单片机的串口1中断处理函数	
 **************************************************************************/
void UART1(void) interrupt 4  // 串行口1中断函数  
{ ; }


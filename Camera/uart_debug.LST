C51 COMPILER V9.00   UART_DEBUG                                                            05/29/2016 10:12:11 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE UART_DEBUG
OBJECT MODULE PLACED IN uart_debug.OBJ
COMPILER INVOKED BY: E:\software\DevelopmentSoftware\InstallSrc\KeilC51\C51\BIN\C51.EXE uart_debug.c LARGE BROWSE DEBUG 
                    -OBJECTEXTEND

line level    source

   1          /****************《51单片机轻松入门-基于STC15W4K系列》配套例程 *************
   2           ★★★★★★★★★★★★★★★★★★★★★★★★
   3           《51单片机轻松入门-基于STC15W4K系列》 一书已经由北航出版社正式出版发行。
   4            作者亲手创作的与教材配套的51双核实验板(2个MCU)对程序下载、调试、仿真方便，不需要外部
   5            仿真器与编程器，这种设计方式彻底解决了系统中多个最高优先级谁也不能让谁的中断竞争问题。
   6            淘宝店地址：https://shop117387413.taobao.com
   7            QQ群：STC51-STM32(3) ：515624099 或 STC51-STM32(2)：99794374。
   8                  验证信息：STC15单片机
   9            邮箱：xgliyouquan@126.com
  10            ★★★★★★★★★★★★★★★★★★★★★★★★*/
  11          
  12          #include "stc15.h"           // 包含 "STC15W4K.H"寄存器定义头文件 
  13          #include <string.h>       
  14          /******************************************************************
  15          功能：将一个32位长整型变量dat转为字符串，比如把1234转为"1234"
  16          参数：dat:待转的long型的变量
  17                str:指向字符数组的指针，转换后的字节串放在其中    
  18          返回：转换后的字符串长度                                
  19           ******************************************************************/ 
  20          unsigned char Long_Str(long dat,unsigned char *str) // 长整型数转换为字符串，返回值为转换后的字符串长度
  21          {
  22   1              signed char i=0;
  23   1              unsigned char len = 0;
  24   1              unsigned char buf[11];     // 长整数最大值4294967295，转ASCII码后占用10+1=11字节 
  25   1              if (dat < 0)               // 如果为负数，首先取绝对值，并添加负号
  26   1              {
  27   2                      dat = -dat;
  28   2                      *str++ = '-';
  29   2                      len++;
  30   2              }
  31   1              do 
  32   1              {                               // 低位在前高位在后顺序排列
  33   2                      buf[i++] = dat % 10+0x30;       // C语言中数组下标固定从0开始
  34   2                      dat /= 10;
  35   2              } while (dat > 0);
  36   1          len += i;                 // i最后的值就是有效字符的个数
  37   1          while (i-- > 0)           // 高位在前低位在后顺序排列
  38   1          {
  39   2              *str++ = buf[i] ;
  40   2          }     
  41   1              *str = 0;                 // 添加字符串结束符方便使用KEIL自带的字符串处理函数处理
  42   1              return len;               // 返回字符串长度
  43   1      }
  44          
  45          /******************************************************************
  46          功能：将一个字符串转为32位长整型变量，比如"1234"转为1234
  47          参数：str:指向待转换的字符串           
  48          返回：转换后的数值                                                                                     
  49           ******************************************** **********************/ 
  50          unsigned long Str_Long(char *str) 
  51          {
  52   1               unsigned long temp=0;
  53   1               unsigned long fact=1;
  54   1               unsigned char len=strlen(str); // <string.h>头文件包含strlen()函数     
C51 COMPILER V9.00   UART_DEBUG                                                            05/29/2016 10:12:11 PAGE 2   

  55   1               unsigned char i;               // strlen()函数计算的字符串长度不包含最后一个空字符(值0)
  56   1               for(i=len;i>0;i--)                                                                                                                        
  57   1               {
  58   2                      temp+=((str[i-1]-0x30)*fact);  // 数组下标从0开始
  59   2                      fact*=10;
  60   2               }
  61   1               return temp;
  62   1      }
  63          
  64          /**************************************************************************
  65          功能：STC15单片机串口1初始化,使用T1方式2自重载方式做波特率发生器 
  66           **************************************************************************/
  67          /*void UART_init(void)
  68          {                 
  69                  // 下面代码设置定时器1
  70                  TMOD |= 0x20;   // 0010 0000 定时器1工作于方式2（8位自动重装方式）
  71                  TH1  = 0xFA;    // 波特率：9600 /22.1184MHZ
  72                  TL1  = 0xFA;    // 波特率：9600 /22.1184MHZ
  73                  TR1  = 1;
  74                  // 下面代码设置定串口
  75                  AUXR = 0x00;             // 很关键，使用定时器1作为波特率发生器，S1ST2=0
  76                  SCON = 0x50;    // 01010 0000 SM0.SM1=01(最普遍的8位通信）,REN=1（允许接受）
  77                  // 下面代码设置中断
  78                  ES   = 1;               // 关键：开启了中断就必须编写相应的中断函数，哪怕是中断空函数，
  79                                  // 但必须有,否则程序进入中断入口地址后（这里是0023H)不能跳出，必然出错
  80                  EA   = 1;
  81          }*/  
  82          
  83          void UART_init(void)            //115200bps@22.1184MHz
  84          {
  85   1              SCON = 0x50;            //8位数据,可变波特率
  86   1              AUXR |= 0x40;           //定时器1时钟为Fosc,即1T
  87   1              AUXR &= 0xFE;           //串口1选择定时器1为波特率发生器
  88   1              TMOD &= 0x0F;           //设定定时器1为16位自动重装方式
  89   1              TL1 = 0xD0;             //设定定时初值
  90   1              TH1 = 0xFF;             //设定定时初值
  91   1              ET1 = 0;                //禁止定时器1中断
  92   1              TR1 = 1;                //启动定时器1
  93   1      }
  94          
  95          
  96          /**************************************************************************
  97          功能：STC15单片机的串口发送字节的函数
  98          参数：dat:要发送的一个字节   
  99          **************************************************************************/
 100          void UART_Send_Byte(unsigned char dat)
 101          {
 102   1              ES=0;            // 使用查询发送结束方式，禁止中断干预
 103   1              SBUF = dat;
 104   1              while(!TI);         
 105   1              TI=0;    //此句可以不要，不影响后面数据的发送，只供代码查询数据是否发送完成
 106   1              ES=1;
 107   1      }       
 108          /**************************************************************************
 109          功能：STC15单片机的串口发送0d 0a ，即回车换行 
 110          注：此函数就是发送0d 0a这两个字节，在"串口助手"上会有回车换行的效果
 111           **************************************************************************/  
 112          void UART_Send_Enter()
 113          {
 114   1              UART_Send_Byte(0x0d); // 转义字符常量\r，ASCII码值（10进制）=13，光标移到本行行首
 115   1              UART_Send_Byte(0x0a); // 转义字符常量\n，ASCII码值（10进制）=10，光标移到下行行首
 116   1      }
C51 COMPILER V9.00   UART_DEBUG                                                            05/29/2016 10:12:11 PAGE 3   

 117          
 118          /*
 119          void UART_Send_Str(char *buf)
 120          {
 121                  while (*buf != '\0')   //说明：C语言字符串数组结尾必然有一个"\0"字符，在内存中数值为0
 122                  {
 123                          UART_send_byte(*buf++);  //说明：* 和 ++优先级相同，结合性从右到左，但是++运
 124                  }                                                        //算符有个特性就是先让变量参与运算，后进行加1操作
 125          }        */
 126          
 127          /**************************************************************************
 128          功能：51单片机的串口发送字符串  
 129          参数：s:指向字符串的指针          
 130          注：如果在字符串中有'\n'，则会发送一个回车换行
 131           **************************************************************************/
 132          void UART_Send_Str(char *s)
 133          {
 134   1              unsigned int i;         
 135   1              unsigned int len=strlen(s)-1;           // 最后一个字符单独处理
 136   1              for(i=0;i<len;i++) 
 137   1                      UART_Send_Byte(s[i]);           //      while (*buf != '\0')  UART_Send_Byte(*s++);
 138   1              if(s[i]=='\n')                       
 139   1              {
 140   2                      UART_Send_Enter();
 141   2              }
 142   1              else
 143   1              {
 144   2                      UART_Send_Byte(s[i]);   // 普通字符正常发送
 145   2              }
 146   1      }
 147          /**************************************************************************
 148          功能：51单片机的串口发送数值
 149          参数：dat:要发送的数值(长整数)
 150            注：函数中会将数值转为相应的字符串，发送出去。比如 4567 转为 "4567" 
 151           **************************************************************************/
 152          void UART_Send_Num(unsigned long dat)
 153          {
 154   1              unsigned char temp[11];         // 长整数最大值4294967295，转ASCII码后占用10字节
 155   1                  //  由于后面程序要使用strlen()库函数计算长度，需增加1个字节存放结束符0
 156   1              Long_Str(dat,temp);       
 157   1              UART_Send_Str(temp);
 158   1              UART_Send_Enter();          // 发送回车 
 159   1      }
 160          /**************************************************************************
 161          功能：51单片机的串口发送调试信息（字符串+数值）   
 162          参数：inf:指向提示信息字符串的指针
 163                dat:一个数值，前面的提示信息就是在说明这个数值的意义
 164           **************************************************************************/
 165          void UART_Send_StrNum(char *inf,unsigned long dat)
 166          {
 167   1              UART_Send_Str(inf);
 168   1              UART_Send_Num(dat);     
 169   1      } 
 170          
 171          void UART_Put_Inf(char *inf,unsigned long dat)
 172          {
 173   1              UART_Send_StrNum(inf, dat);
 174   1      }
 175          
 176          /**************************************************************************
 177          功能：16进制转ASCII码函数
 178           **************************************************************************/
C51 COMPILER V9.00   UART_DEBUG                                                            05/29/2016 10:12:11 PAGE 4   

 179          unsigned char Hex_ASCII(unsigned int hex,char *str)
 180          {
 181   1              unsigned char temp=0;
 182   1              
 183   1              temp=((hex&0xf000)>>12);          // 4位1表示范围0_9_A_F
 184   1              str[0]=(temp>=10)?(temp-10+'A'):(temp+0x30);
 185   1                      // 0_9的ASCII码是0_9+ 0x30，
 186   1                  // A_F的ASCII码: A代表数值10，A的ASCII码是65，因此数值+55=ASCII
 187   1                      // 因此算式(temp-10+'A')=(temp-10+65)=(temp+55)
 188   1                      // 分析依据：ASCII码表
 189   1              temp=((hex&0x0f00)>>8);
 190   1              str[1]=(temp>=10)?(temp-10+'A'):(temp+0x30);
 191   1              
 192   1              temp=((hex&0x00f0)>>4);
 193   1              str[2]=(temp>=10)?(temp-10+'A'):(temp+0x30);
 194   1              
 195   1              temp=((hex&0x000f)>>0);
 196   1              str[3]=(temp>=10)?(temp-10+'A'):(temp+0x30);
 197   1              
 198   1              str[4]=0;           // 由于要使用KEIL自带的字符串处理函数处理，必须有结束标记。 
 199   1              
 200   1              return 0;
 201   1      } 
 202          
 203          /**************************************************************************
 204          功能：51单片机的串口输出ASCII码函数（接收端按字符形式接收则显示为HEX格式        ）
 205           **************************************************************************/
 206          void UART_Send_Hex(unsigned int hex)
 207          {
 208   1              unsigned char temp[11];
 209   1              Hex_ASCII(hex,temp);
 210   1              UART_Send_Str(temp);
 211   1              UART_Send_Enter();          // 发送回车
 212   1      }
 213          
 214          /**************************************************************************
 215          功能：51单片机的串口发送调试信息（二进制数据显示）        
 216          参数：dat:需要按2进制形式显示变量
 217           **************************************************************************/
 218          void UART_Send_binary(unsigned char dat)
 219          {
 220   1              unsigned char i;
 221   1              unsigned char a[17];
 222   1              for(i=0;i<8;i++)
 223   1              {
 224   2                      a[i]=((dat<<i)&0x80)?'1':'0';
 225   2              }
 226   1              a[i]=0;
 227   1              for(i=0;i<strlen(a);i++)
 228   1              {
 229   2                      UART_Send_Byte(a[i]);
 230   2                      UART_Send_Byte(' ');
 231   2              }
 232   1              UART_Send_Enter();          // 发送回车
 233   1      }
 234          /**************************************************************************
 235          功能：51单片机的串口1中断处理函数       
 236           **************************************************************************/
 237          void UART1(void) interrupt 4  // 串行口1中断函数  
 238          { ; }
 239          

C51 COMPILER V9.00   UART_DEBUG                                                            05/29/2016 10:12:11 PAGE 5   


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    961    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      81
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
